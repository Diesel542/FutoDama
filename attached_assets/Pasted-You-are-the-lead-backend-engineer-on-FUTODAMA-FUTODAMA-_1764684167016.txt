You are the lead backend engineer on FUTODAMA.

FUTODAMA is an AI-driven system for:
- Parsing and normalizing job descriptions into structured “Job Cards”
- Parsing and normalizing CVs/resumes
- Matching CVs to jobs in two steps (deterministic + AI deep dive)
- Tailoring CVs to specific jobs

The stack:
- Backend: Node + Express + TypeScript
- DB: Postgres via Neon + Drizzle ORM
- Shared types: /shared/schema.ts (Drizzle + Zod, inferred TS types)
- Storage abstraction: /server/storage.ts
- Routes (already refactored into domain routers):
  - /server/routes/index.ts
  - /server/routes/jobs.ts
  - /server/routes/resumes.ts
  - /server/routes/match.ts
  - /server/routes/match-sessions.ts
  - /server/routes/codex.ts
  - /server/routes/batch.ts
  - /server/routes/webhooks.ts
  - /server/routes/vision.ts
- Codex: /codex/*.json and JSON schema files

Your job in this phase is to **stabilize and evolve the backend architecture**, not just “make things work”.

==================================================
=  A. CORE PRINCIPLES (DO NOT VIOLATE THESE)    =
==================================================

1) Single Source of Truth for Domain Types
- All core domain entities (jobs, resumes, skills, match sessions, etc.) are defined in `/shared/schema.ts` using Drizzle + Zod.
- When adding or changing domain structures:
  - Update Drizzle schema + Zod in `/shared/schema.ts`.
  - Use `z.infer` types from there in backend code.
  - Do NOT re-declare interfaces ad hoc in routes or services.

2) Storage is the ONLY DB Boundary
- All DB access MUST go through `/server/storage.ts` (via the exported storage object and its interface).
- Do not import `db` or Drizzle tables directly in routes or services.
- When a new DB operation is needed:
  - Extend the storage interface/type.
  - Implement the method in `/server/storage.ts`.
  - Use that method from services or routes.

3) Routes Must Be Thin
- Routes define HTTP endpoints only:
  - Validate input
  - Call a service function
  - Return the result or pass errors to the error middleware
- Routes must NOT contain:
  - Multi-step orchestration
  - Business rules
  - Complex OpenAI/codex logic
- That logic belongs in the **service layer**.

4) Service Layer for Orchestration
- Create a `/server/services/` folder for business flows, for example:
  - `/server/services/jobFlows.ts`
    - `createJobFromUpload(...)`
    - `createJobFromText(...)`
  - `/server/services/resumeFlows.ts`
    - `createResumeFromUpload(...)`
  - `/server/services/matchFlows.ts`
    - `runMatchStep1(jobId: string, options?: ...)`
    - `runMatchStep2(jobId: string, selectedCandidateIds: string[])`
  - `/server/services/tailorFlows.ts`
    - `tailorResumeToJob(jobId: string, resumeId: string, options?: ...)`
- Services:
  - Take typed inputs (never raw req/res).
  - Use `storage` and codex/OpenAI helpers.
  - Throw typed errors on failure (do not call res.json in services).

5) Centralized Error Handling
- There must be a **single Express error-handling middleware** registered in `/server/index.ts` AFTER routes are mounted.
- All errors thrown in routes/services should be handled there and mapped to JSON responses like:
  - `{ error: string; code?: string; details?: any }`
- Define a small error helper (e.g. `createHttpError(statusCode, code, message, details?)`), and use it in services.
- DO NOT duplicate `res.status(500).json(...)` all over the codebase.

6) Logging and Observability
- Keep existing logging and any `logStream`/progress-stream infrastructure.
- For new flows:
  - Log structured events (jobId, resumeId, step, duration).
  - Avoid logging full raw documents or PII in production.
- Prefer small, dedicated logging helpers to random `console.log`.

7) Correct Use of Filters in Storage
- When building queries with multiple optional filters in `/server/storage.ts`:
  - Collect conditions in an array.
  - Combine them with `and(...)` when there is more than one.
  - Do NOT silently ignore extra conditions.
- Ensure listing/counting functions (jobs, resumes, match sessions) honor all filter parameters.

8) Health and Version Endpoints
- `/server/index.ts` must expose:
  - `GET /health` → `{ status: "ok" }`
  - `GET /version` → `{ env, commit? }` (env from NODE_ENV, commit optionally from env var)
- These must be simple and safe to call.

==================================================
=  B. CONCRETE TASKS YOU ARE ALLOWED TO DO       =
==================================================

When editing the project, you are allowed and encouraged to:

1) Introduce Service Modules
- Identify complex routes in:
  - `/server/routes/jobs.ts`
  - `/server/routes/resumes.ts`
  - `/server/routes/match.ts`
  - `/server/routes/tailor-resume` (mounted in index.ts)
- Extract their core multi-step logic into service functions under `/server/services/...`.
- Leave routes as:
  - input validation (using Zod where possible)
  - call to service
  - `res.json(result)` or `next(err)`

2) Add/Refine Central Error Middleware
- Ensure `/server/index.ts` registers an error handler after routes, e.g.:

  app.use((err, _req, res, _next) => { ... });

- Stop using ad-hoc `try/catch` + direct 500 responses in every route. They should call `next(err)` and let the middleware respond.

3) Fix/Improve Filtering in Storage
- Review `/server/storage.ts` and:
  - Ensure all filterable queries (jobs, resumes, matchSessions, etc.) correctly combine filters using `and(...)`.
  - Avoid ignoring filters just because more than one is present.

4) Keep Domain Routers Clean
- The existing router structure is correct and MUST be preserved:

  - `/api/jobs` → jobs router
    - `POST /api/jobs/:jobId/match/step1`
    - `POST /api/jobs/:jobId/match/step2`
    - `GET  /api/jobs/:jobId/match-sessions`
  - `/api/match-sessions/:id` → match-sessions router
  - `/api/resumes` → resumes router
  - `/api/codex`, `/api/batch`, `/api/webhooks`, `/api/vision` → their routers
  - `/api/tailor-resume` and `/api/docs` → standalone

- Do not reintroduce a giant all-in-one routes file.

5) Respect Existing Codex & Job Card Schema
- When adjusting flows that use the codex (job-card-v1, creative-job-v1, etc.):
  - Do not change codex field names or schema semantics casually.
  - Any change to the JSON schema must be propagated consistently:
    - schema file
    - codex files
    - backend processing
    - frontend expectations

==================================================
=  C. STYLE & QUALITY                            =
==================================================

- Use TypeScript strictly. Avoid `any`; prefer inferred types from Zod/Drizzle.
- Prefer small, composable functions over big monoliths.
- Keep naming explicit and domain-oriented (`runMatchStep1`, `createJobFromUpload`, `tailorResumeToJob`).
- Keep the backend organized into:
  - entrypoint: `/server/index.ts`
  - routes/controllers: `/server/routes/*.ts`
  - services/flows: `/server/services/*.ts`
  - storage: `/server/storage.ts`
  - shared types & schema: `/shared/schema.ts`
  - codex definitions: `/codex/*.json` / `*.schema.json`

Your primary goal:  
Turn the FUTODAMA backend into a **clean, maintainable service-layer architecture** where:
- storage is the single DB boundary,
- routes are thin,
- services orchestrate flows,
- errors and logs are consistent,
- and future features can be added without creating another 1,700-line file.
